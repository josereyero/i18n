<?php
// $Id: i18n_taxonomy.module,v 1.1.2.3 2011/02/14 11:36:29 jareyero Exp $

/**
 * @file
 * i18n taxonomy module
 *
 * Internationalization (i18n) package.
 *
 * This module groups together all existing i18n taxonomy functionality
 * providing several options for taxonomy translation.
 *
 * Translates taxonomy term for selected vocabularies running them through the localization system.
 * It also translates terms for views filters and views results.
 *
 * @author Jose A. Reyero, 2004
 */

/**
 * Implements hook_help().
 */
function i18n_taxonomy_help($path, $arg) {
  switch ($path) {
    case 'admin/help#i18n_taxonomy' :
      $output = '<p>'. t('This module adds support for multilingual taxonomy. You can set up multilingual options for each vocabulary:') .'</p>';
      $output .= '<ul>';
      $output .= '<li>'. t('A language can be assigned globaly for a vocabulary.') .'</li>';
      $output .= '<li>'. t('Different terms for each language with translation relationships.') .'</li>';
      $output .= '<li>'. t('Terms can be common to all languages, but may be localized.') .'</li>';
      $output .= '</ul>';
      $output .= '<p>'. t('To search and translate strings, use the <a href="@translate-interface">translation interface</a> pages.', array('@translate-interface' => url('admin/build/translate'))) .'</p>';
      $output .= '<p>'. t('For more information, see the online handbook entry for <a href="@i18n">Internationalization module</a>.', array('@i18n' => 'http://drupal.org/node/133977')) .'</p>';
      return $output;

    case 'admin/settings/language/i18n':
      $output = '<ul>';
      $output .= '<li>'. t('To set up multilingual options for vocabularies go to <a href="@configure_taxonomy">Taxonomy configuration page</a>.', array('@configure_taxonomy' => url('admin/content/taxonomy'))) .'</li>';
      $output .= '</ul>';
      return $output;

    case 'admin/content/taxonomy/%':
      $vocabulary = taxonomy_vocabulary_load($arg[3]);
      switch (i18n_taxonomy_vocabulary_mode($vocabulary->vid)) {
        case I18N_MODE_LOCALIZE:
          return '<p>'. t('%capital_name is a localizable vocabulary. You will be able to translate term names and descriptions using the <a href="@translate-interface">translate interface</a> pages.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name, '@translate-interface' => url('admin/build/translate'))) .'</p>';

        case I18N_MODE_LANGUAGE:
          return '<p>'. t('%capital_name is a vocabulary with a fixed language. All the terms in this vocabulary will have %language language.', array('%capital_name' => drupal_ucfirst($vocabulary->name), '%name' => $vocabulary->name, '%language' => i18n_language_property($vocabulary->language, 'name'))) .'</p>';

        case I18N_MODE_TRANSLATE:
          return '<p>'. t('%capital_name is a full multilingual vocabulary. You will be able to set a language for each term and create translation relationships.', array('%capital_name' => drupal_ucfirst($vocabulary->name))) .'</p>';
      }

  }
}

/**
 * Returns list of vocabulary modes.
 */
function _i18n_taxonomy_vocabulary_options() {
  return array(
    I18N_MODE_NONE => t('None. No multilingual options for this vocabulary.'),
    I18N_MODE_LOCALIZE => t('Localize terms. Terms are common for all languages, but their name and description may be localized.'),
    I18N_MODE_TRANSLATE => t('Per language terms. Different terms will be allowed for each language and they can be translated.'),
    I18N_MODE_LANGUAGE => t('Set language to vocabulary. The vocabulary will have a global language and it will only show up for pages in that language.'),
  );
}

/**
 * Implements hook_menu().
 */
function i18n_taxonomy_menu() {
  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/translation'] = array(
    'title' => 'Translation',
    'page callback' => 'i18n_taxonomy_translation_overview',
    'page arguments' => array(3),
    'access callback' => '_i18n_taxonomy_translation_tab',
    'access arguments' => array(3),
    'type' => MENU_LOCAL_TASK,
    //'parent' => 'admin/content/taxonomy/%taxonomy_vocabulary',
    'file' => 'i18n_taxonomy.admin.inc',
  );
  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/translation/add'] = array(
    'title' => 'Create new translation',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('i18n_taxonomy_translation_term_form', 3),
    'access callback' => '_i18n_taxonomy_translation_tab',
    'access arguments' => array(3),
    'type' => MENU_LOCAL_ACTION,
    //'parent' => 'admin/content/taxonomy/%taxonomy_vocabulary',
    'file' => 'i18n_taxonomy.admin.inc',
  );
  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/translation/edit/%i18n_taxonomy_translation_set'] = array(
    'title' => 'Edit translation',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('i18n_taxonomy_translation_term_form', 3, 6),
    'access callback' => '_i18n_taxonomy_translation_tab',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK,
    //'parent' => 'admin/content/taxonomy/%taxonomy_vocabulary',
    'file' => 'i18n_taxonomy.admin.inc',
  );
  $items['i18n/taxonomy/autocomplete/%taxonomy_vocabulary_machine_name'] = array(
    'title' => 'Autocomplete taxonomy',
    'page callback' => 'i18n_taxonomy_autocomplete',
    'page arguments' => array(3),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'i18n_taxonomy.pages.inc',
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * Take over the taxonomy pages
 */
function i18n_taxonomy_menu_alter(&$items) {
  // If ctool's page manager is active for the path skip this modules override.
  if (variable_get('page_manager_term_view_disabled', TRUE)) {
    // Taxonomy term page. Localize terms.
    $items['taxonomy/term/%taxonomy_term']['module'] = 'i18n_taxonomy';
    $items['taxonomy/term/%taxonomy_term']['page callback'] = 'i18n_taxonomy_term_page';
    $items['taxonomy/term/%taxonomy_term']['file'] = 'i18n_taxonomy.pages.inc';
  }

  // Localize autocomplete
  $items['taxonomy/autocomplete']['module'] = 'i18n_taxonomy';
  $items['taxonomy/autocomplete']['page callback'] = 'i18n_taxonomy_autocomplete';
  $items['taxonomy/autocomplete']['file'] = 'i18n_taxonomy.pages.inc';
}

/**
 * Menu access callback. Show tab only for full multilingual vocabularies.
 */
function _i18n_taxonomy_translation_tab($vocabulary) {
  return user_access('administer taxonomy') && i18n_taxonomy_vocabulary_mode($vocabulary->vid) & I18N_MODE_TRANSLATE;
}

/**
 * Implements hook_field_formatter_info().
 */
function i18n_taxonomy_field_formatter_info() {
  return array(
    'i18n_taxonomy_term_reference_link' => array(
      'label' => t('Link (localized)'),
      'field types' => array('taxonomy_term_reference'),
    ),
    'i18n_taxonomy_term_reference_plain' => array(
      'label' => t('Plain text (localized)'),
      'field types' => array('taxonomy_term_reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * This preloads all taxonomy terms for multiple loaded objects at once and
 * unsets values for invalid terms that do not exist.
 */
function i18n_taxonomy_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  return taxonomy_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, $items, $displays);
}

/**
 * Implements hook_field_formatter_view().
 */
function i18n_taxonomy_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  // Terms whose tid is 'autocreate' do not exist
  // yet and $item['taxonomy_term'] is not set. Theme such terms as
  // just their name.

  switch ($display['type']) {
    case 'i18n_taxonomy_term_reference_link':
      foreach ($items as $delta => $item) {
        if ($item['tid'] == 'autocreate') {
          $element[$delta] = array(
            '#markup' => check_plain($item['name']),
          );
        }
        else {
          $term = $item['taxonomy_term'];
          $uri = entity_uri('taxonomy_term', $term);
          $element[$delta] = array(
            '#type' => 'link',
            '#title' => i18n_taxonomy_term_name($term, $langcode),
            '#href' => $uri['path'],
            '#options' => $uri['options'],
          );
        }
      }
      break;

    case 'i18n_taxonomy_term_reference_plain':
      foreach ($items as $delta => $item) {
        $name = ($item['tid'] != 'autocreate' ? i18n_taxonomy_term_name($item['taxonomy_term'], $langcode): $item['name']);
        $element[$delta] = array(
          '#markup' => check_plain($name),
        );
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_extra_fields().
 */
function i18n_taxonomy_field_extra_fields() {
  $return = array();
  $info = entity_get_info('taxonomy_term');
  foreach (array_keys($info['bundles']) as $bundle) {
    $vocabulary = taxonomy_vocabulary_machine_name_load($bundle);
    if (i18n_taxonomy_vocabulary_mode($vocabulary, I18N_MODE_TRANSLATE)) {
      $return['taxonomy_term'][$bundle] = i18n_language_field_extra();
    }
  }
  return $return;
}

/**
 * Implements hook_field_attach_view_alter().
 */
function i18n_taxonomy_field_attach_view_alter(&$output, $context) {
  if ($context['entity_type'] == 'taxonomy_term' && i18n_taxonomy_vocabulary_mode($context['entity']->vid, I18N_MODE_TRANSLATE)) {
    $output['language'] = array(
      '#type' => 'item',
      '#title' => t('Language'),
      '#markup' => i18n_language_name($context['entity']->language),
    );
  }
}

/**
 * Implements hook_field_info_alter()
 */
function i18n_taxonomy_field_info_alter(&$info) {
  // Change default formatter for term reference fields
  $info['taxonomy_term_reference']['default_formatter'] = 'i18n_taxonomy_term_reference_link';
  // Change module for this field. Basically we take over this field and this means
  // we need to implement a bunch of hooks for fields and options, including hook_field_schema()
  $info['taxonomy_term_reference']['module'] = 'i18n_taxonomy';
}

/**
 * Implements hook_field_is_empty().
 */
function i18n_taxonomy_field_is_empty($item, $field) {
  return taxonomy_field_is_empty($item, $field);
}

/**
 * Implements hook_field_widget_error().
 */
function i18n_taxonomy_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

/**
 * Implements hook_field_widget_form().
 */
function i18n_taxonomy_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  return taxonomy_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
}

/**
 * Implements hook_field_settings_form().
 */
function i18n_taxonomy_field_settings_form($field, $instance, $has_data) {
  return taxonomy_field_settings_form($field, $instance, $has_data);
}

/**
 * Implements hook_field_validate().
 */
function i18n_taxonomy_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  return taxonomy_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, $errors);
}

/**
 * Implements hook_field_presave().
 *
 * Create any new terms defined in a freetagging vocabulary.
 */
function i18n_taxonomy_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  return taxonomy_field_presave($entity_type, $entity, $field, $instance, $langcode, $items);
}

/**
 * Implements hook_field_insert().
 */
function i18n_taxonomy_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  return taxonomy_field_insert($entity_type, $entity, $field, $instance, $langcode, $items);
}

/**
 * Implements hook_field_update().
 */
function i18n_taxonomy_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  return taxonomy_field_update($entity_type, $entity, $field, $instance, $langcode, $items);
}

/**
 * Implements hook_options_list().
 */
function i18n_taxonomy_options_list($field) {
  $function = !empty($field['settings']['options_list_callback']) ? $field['settings']['options_list_callback'] : 'i18n_taxonomy_allowed_values';
  return $function($field);
}

/**
 * Returns the set of valid terms for a taxonomy field.
 *
 * @param $field
 *   The field definition.
 * @return
 *   The array of valid terms for this field, keyed by term id.
 */
function i18n_taxonomy_allowed_values($field) {
  $options = array();
  foreach ($field['settings']['allowed_values'] as $tree) {
    if ($vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {
      if ($terms = taxonomy_get_tree($vocabulary->vid, $tree['parent'])) {
        foreach ($terms as $term) {
          $options[$term->tid] = str_repeat('-', $term->depth) . i18n_taxonomy_term_name($term);
        }
      }
    }
  }
  return $options;
}

/**
 * Implements hook_i18n_string_info()
 */
function i18n_taxonomy_i18n_string_info() {
  $groups['taxonomy'] = array(
    'title' => t('Taxonomy'),
    'description' => t('Vocabulary titles and term names for localizable vocabularies.'),
    'format' => FALSE, // This group doesn't have strings with format
    'list' => FALSE, // This group cannot list all strings
    'refresh callback' => 'i18n_taxonomy_i18n_string_refresh',
  );
  return $groups;
}

/**
 * Refresh strings.
 */
function i18n_taxonomy_i18n_string_refresh($group) {
  if ($group == 'taxonomy' || $group == 'all') {
    foreach (taxonomy_get_vocabularies() as $vid => $vocabulary) {
      if (empty($vocabulary->language)) {
        i18n_string_object_update('taxonomy_vocabulary', $vocabulary);
      }
      if (i18n_taxonomy_vocabulary_mode($vid) & I18N_MODE_LOCALIZE) {
        foreach (taxonomy_get_tree($vid, 0) as $term) {
          i18n_string_object_update('taxonomy_term', $term);
        }
      }
    }
    return TRUE; // Meaning it completed with no issues
  }
}

/**
 * Implements hook_language_switch_links_alter().
 * 
 * Replaces links with pointers to translated versions of the content.
 */
function i18n_taxonomy_language_switch_links_alter(array &$links, $type, $path) {
  if (preg_match("/^(taxonomy\/term\/)([^\/]*)(.*)$/", $path, $matches)) { //or at a taxonomy-listing?
    foreach ($links as $langcode => $link) {
      if ($str_tids = i18n_taxonomy_translation_tids($matches[2], $langcode)) {
        $links[$langcode]['href'] = "taxonomy/term/$str_tids". $matches[3];
      }
    }
  }  
}

/**
 * Implements hook_theme().
 */
function i18n_taxonomy_theme() {
  return array(
    'i18n_taxonomy_term_page' => array(
      'arguments' => array('tids' => array(), 'result' => NULL),
      'file' => 'i18n_taxonomy.pages.inc',
    ),
  );
}

/**
 * Get localized term name
 */
function i18n_taxonomy_term_name($term, $langcode = NULL) {
  return i18n_taxonomy_vocabulary_mode($term->vid, I18N_MODE_LOCALIZE) ? i18n_string(array('taxonomy', 'term', $term->tid, 'name'), $term->name, array('langcode' => $langcode)) : $term->name;
}

/**
 * Get localized vocabulary name
 */
function i18n_taxonomy_vocabulary_name($vocabulary, $langcode = NULL) {
  return i18n_object_langcode($vocabulary) ? $vocabulary->name : i18n_string(array('taxonomy', 'vocabulary', $vocabulary->vid, 'name'), $vocabulary->name, array('langcode' => $langcode));
}

/**
 * Get translated term's tid.
 *
 * @param $tid
 *   Node nid to search for translation.
 * @param $language
 *   Language to search for the translation, defaults to current language.
 * @param $default
 *   Value that will be returned if no translation is found.
 * @return
 *   Translated term tid if exists, or $default.
 */
function i18n_taxonomy_translation_term_tid($tid, $language = NULL, $default = NULL) {
  $translation = db_query('SELECT t.tid FROM {taxonomy_term_data} t INNER JOIN {taxonomy_term_data} a ON t.i18n_tsid = a.i18n_tsid AND t.tid <> a.tid WHERE a.tid = :tid AND t.language = :language AND t.trid > 0', array(
    ':tid' => $tid,
    ':language' =>$language ? $language : i18n_language()->language
  ))->fetchField();
  return $translation ? $translation : $default;
}

/**
 *  Returns an url for the translated taxonomy-page, if exists.
 */
function i18n_taxonomy_translation_tids($str_tids, $lang) {
  if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $str_tids)) {
    $separator = '+';
    // The '+' character in a query string may be parsed as ' '.
    $tids = preg_split('/[+ ]/', $str_tids);
  }
  elseif (preg_match('/^([0-9]+,)*[0-9]+$/', $str_tids)) {
    $separator = ',';
    $tids = explode(',', $str_tids);
  }
  else {
    return;
  }
  $translated_tids = array();
  foreach ($tids as $tid) {
    if ($translated_tid = i18n_taxonomy_translation_term_tid($tid, $lang)) {
      $translated_tids[] = $translated_tid;
    }
  }
  return implode($separator, $translated_tids);
}

/**
 * Implements hook_taxonomy_term_insert()
 */
function i18n_taxonomy_taxonomy_term_insert($term) {
  i18n_taxonomy_taxonomy_term_update($term);
}

/**
 * Implements hook_taxonomy_term_update()
 */
function i18n_taxonomy_taxonomy_term_update($term) {
  if (i18n_taxonomy_vocabulary_mode($term->vid, I18N_MODE_LOCALIZE)) {
    i18n_string_object_update('taxonomy_term', $term);
  }  
}

/**
 * Implements hook_taxonomy_term_delete()
 */
function i18n_taxonomy_taxonomy_term_delete($term) {
  i18n_string_object_remove('taxonomy_term', $term);
}

/**
 * Implements hook_taxonomy_vocabulary_insert()
 */
function i18n_taxonomy_taxonomy_vocabulary_insert($vocabulary) {
  i18n_taxonomy_taxonomy_vocabulary_udpate($vocabulary);
}

/**
 * Implements hook_taxonomy_vocabulary_update()
 */
function i18n_taxonomy_taxonomy_vocabulary_udpate($vocabulary) {
  // Update language for related terms
  switch ($vocabulary->i18n_mode) {
    case I18N_MODE_LANGUAGE:
      $update['language'] = $vocabulary->language;
      break;
    case I18N_MODE_NONE:
      $update['language'] = LANGUAGE_NONE;
      break;
  }
  if (isset($update)) {
    db_update('taxonomy_term_data')
      ->fields($update)
      ->condition('vid', $vocabulary->vid)
      ->execute();
    drupal_set_message(t('Reset language for all terms.'));
  }
  // Update strings, always add translation if no language
  if (!i18n_object_langcode($vocabulary)) {
    i18n_string_object_update('taxonomy_vocabulary', $vocabulary);
  }
}

/**
 * Implements hook_taxonomy_vocabulary_insert()
 */
function i18n_taxonomy_taxonomy_vocabulary_delete($vocabulary) {
  i18n_string_object_remove('taxonomy_vocabulary', $vocabulary);
}

/**
 * Implements hook_taxonomy_term_presave()
 */
function i18n_taxonomy_taxonomy_term_presave($term) {
  switch (i18n_taxonomy_vocabulary_mode($term->vid)) {
    case I18N_MODE_LANGUAGE; // Predefined language for all terms
      $term->language = taxonomy_vocabulary_load($term->vid)->language;
      break;
    case I18N_MODE_TRANSLATE: // Multilingual terms, translatable
      if (!isset($term->language)) {
         // The term may come from a node tags field, just if this is not a taxonomy form
        $term->language = i18n_langcode();
      }
      // Only for the case the term has no language, it may need to be removed from translation set
      if (empty($term->language)) {
        $term->trid = 0;
      }
      break;    
  }  
}

/**
 * Implements hook_form_FORM_ID_alter()
 */
function i18n_taxonomy_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  $vocabulary = $form_state['vocabulary'];
  drupal_add_js(drupal_get_path('module', 'i18n_taxonomy') . '/i18n_taxonomy.js');
  drupal_add_js(array('i18n_taxonomy_vocabulary_form' => array('I18N_MODE_LANGUAGE' => I18N_MODE_LANGUAGE)), 'setting');
  $form['i18n'] = array(
    '#type' => 'fieldset',
    '#title' => t('Multilingual options'),
    '#collapsible' => TRUE,
    '#weight' => 0,
  );
  $form['i18n']['i18n_mode'] = array(
    '#type' => 'radios',
    '#title' => t('Translation mode'),
    '#options' => _i18n_taxonomy_vocabulary_options(),
    '#default_value' => i18n_taxonomy_vocabulary_mode($vocabulary),
    '#description' => t('For localizable vocabularies, to have all terms available for translation visit the <a href="@locale-refresh">translation refresh</a> page.', array('@locale-refresh' => url('admin/build/translate/refresh'))),
  );
  $form['i18n']['language'] = array(
    '#type' => 'select',
    '#title' => t('Language'),
    '#default_value' => !empty($vocabulary->language) ? $vocabulary->language : LANGUAGE_NONE,
    '#options' => array(LANGUAGE_NONE => '') + i18n_language_list(),
    '#description' => t('Language for this vocabulary. If set, it will apply to all terms in this vocabulary.'),
    '#disabled' => $vocabulary && !i18n_taxonomy_vocabulary_mode($vocabulary, I18N_MODE_LANGUAGE),
  );
  $form['#validate'][] = 'i18n_taxonomy_form_vocabulary_validate';
}

/**
 * Implements hook_form_FORM_ID_alter()
 */
function i18n_taxonomy_form_taxonomy_form_term_alter(&$form, &$form_state) {
  // Check for confirmation forms
  if (isset($form_state['confirm_delete']) || isset($form_state['confirm_parents'])) return;

  $term = $form_state['term'];
  $vocabulary = $form['#vocabulary'];

  // Mark form so we can know later when saving the term it came from a taxonomy form
  $form['i18n_taxonomy_form'] = array('#type' => 'value', '#value' => 1);

  // Add language field or not depending on taxonomy mode.
  switch (i18n_taxonomy_vocabulary_mode($vocabulary->vid)) {
    case I18N_MODE_TRANSLATE:
      $form['language'] = array(
        '#type' => 'select',
        '#title' => t('Language'),
        '#default_value' => isset($term) && !empty($term->language) ? $term->language : '',
        '#options' => array('' => '') + i18n_language_list(),
        '#description' => t('This term belongs to a multilingual vocabulary. You can set a language for it.'),
      );
      break;

    case I18N_MODE_LANGUAGE:
      $form['language'] = array(
        '#type' => 'value',
        '#value' => $vocabulary->language
      );
      $form['identification']['language_info'] = array('#value' => t('All terms in this vocabulary have a fixed language: %language', array('%language' => i18n_language_name($vocabulary->language))));
      break;

    case I18N_MODE_LOCALIZE:
      $form['language'] = array(
        '#type' => 'value',
        '#value' => LANGUAGE_NONE,
      );
      i18n_string_element_mark($form['name']);
      i18n_string_element_mark($form['description']);
      break;

    case I18N_MODE_NONE:
    default:
      $form['language'] = array(
        '#type' => 'value',
        '#value' => LANGUAGE_NONE,
      );
      break;
  }
}

/**
 * Implements hook_form_alter().
 *
 * This is the place to add language fields to all forms.
 *
 * @ TO DO The vocabulary form needs some javascript.
 */
function i18n_taxonomy_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    case 'taxonomy_overview_vocabularies':
      $vocabularies = taxonomy_get_vocabularies();
      foreach ($vocabularies as $vocabulary) {
        if (i18n_object_langcode($vocabulary)) {
          $form[$vocabulary->vid]['name']['#markup'] .= ' ('. i18n_language_name($vocabulary->language) .')';
        }
      }
      break;

    case 'taxonomy_overview_terms':
      if (i18n_taxonomy_vocabulary_mode($form['#vocabulary']->vid) & I18N_MODE_TRANSLATE) {
        foreach (element_children($form) as $key) {
          if (isset($form[$key]['#term']) && ($lang = i18n_object_langcode($form[$key]['#term']))) {
            $form[$key]['view']['#suffix'] = ' ('. i18n_language_name($lang) .')';
          }
        }
      }
      break;

    case 'search_form':
      // Localize category selector in advanced search form.
      if (!empty($form['advanced']) && !empty($form['advanced']['category'])) {
        i18n_taxonomy_form_all_localize($form['advanced']['category']);
      }
      break;
  }
}

/**
 * Validate multilingual options for vocabulary form
 */
function i18n_taxonomy_form_vocabulary_validate($form, &$form_state) {
  $language = i18n_object_langcode($form_state['values']['language']);
  $mode = $form_state['values']['i18n_mode'];
  if ($mode != I18N_MODE_LANGUAGE && $language) {
    form_set_error('language', t('Setting a vocabulary language only makes sense in the "Set language to vocabulary" translation mode. Either change to this mode or do not select a language.'));
  }
  elseif ($mode == I18N_MODE_LANGUAGE && !$language ) {
    form_set_error('language', t('If selecting "Set language to vocabulary" you need to set a language to this vocabulary. Either change the translation mode or select a language.'));
  }
}

/**
 * Localize a taxonomy_form_all() kind of control
 *
 * The options array is indexed by vocabulary name and then by term id, with tree structure
 * We just need to localize vocabulary name and localizable terms. Multilingual vocabularies
 * should have been taken care of by query rewriting.
 **/
function i18n_taxonomy_form_all_localize(&$item) {
  $options = &$item['#options'];
  foreach (taxonomy_get_vocabularies() as $vid => $vocabulary) {
    if (!empty($options[$vocabulary->name])) {
      // Localize vocabulary name if translated
      $vname = i18n_taxonomy_vocabulary_name($vocabulary);
      if ($vname != $vocabulary->name) {
        $options[$vname] = $options[$vocabulary->name];
        unset($options[$vocabulary->name]);
      }
      if (i18n_taxonomy_vocabulary_mode($vid) & I18N_MODE_LOCALIZE) {
        $tree = taxonomy_get_tree($vid);
        if ($tree && (count($tree) > 0)) {
          foreach ($tree as $term) {
            if (isset($options[$vname][$term->tid])) {
              $options[$vname][$term->tid] = str_repeat('-', $term->depth) . i18n_taxonomy_term_name($term);
            }
          }
        }
      }
    }
  }
}

/**
 * Get term translations for multilingual terms. This works for multilingual vocabularies.
 *
 * @param $params
 *   Array of query conditions. I.e. array('tid' => xxx)
 * @param $getall
 *   Whether to get the original term too in the set or not.
 *
 * @return
 *   An array of the from lang => Term.
 */
function i18n_taxonomy_term_get_translations($params, $getall = TRUE) {
  foreach ($params as $field => $value) {
    $conds[] = "i.$field = '%s'";
    $values[] = $value;
  }
  if (!$getall) { // If not all, a parameter must be tid.
    $conds[] = "t.tid != %d";
    $values[] = $params['tid'];
  }
  $conds[] = "t.trid != 0";
  $sql = 'SELECT t.* FROM {term_data} t INNER JOIN {term_data} i ON t.trid = i.trid WHERE '. implode(' AND ', $conds);;
  $result = db_query($sql, $values);
  $items = array();
  while ($data = db_fetch_object($result)) {
    $items[$data->language] = $data;
  }
  return $items;
}

/**
 * Implements hook_node_view().
 * 
 * Localize breadcrumb for forum nodes.
 */
function i18n_taxonomy_node_view($node, $view_mode, $langcode) {
  if (_forum_node_check_node_type($node)) {
    if ($view_mode == 'full' && node_is_page($node)) {
      $vid = variable_get('forum_nav_vocabulary', 0);
      $vocabulary = taxonomy_vocabulary_load($vid);
      // Breadcrumb navigation
      $breadcrumb[] = l(t('Home'), NULL);
      $breadcrumb[] = l(i18n_taxonomy_vocabulary_name($vocabulary), 'forum');
      if ($parents = taxonomy_get_parents_all($node->forum_tid)) {
        $parents = array_reverse($parents);
        foreach ($parents as $parent) {
          $breadcrumb[] = l(i18n_taxonomy_term_name($parent), 'forum/' . $parent->tid);
        }
      }
      drupal_set_breadcrumb($breadcrumb);
    }
  }
}

/**
 * Implements hook_node_prepare().
 */
function i18n_taxonomy_node_prepare($node) {
  // Taxonomy translation.
  /*
  if (is_array($source->taxonomy)) {
    // Set translated taxonomy terms.
    $node->taxonomy = i18n_taxonomy_translate_terms($source->taxonomy, $node->language);
  }
  */
}

/**
 * Find all terms associated with the given node, ordered by vocabulary and term weight.
 *
 * Same as taxonomy_node_get_terms() but without static caching.
 */
function i18n_taxonomy_node_get_terms($node, $key = 'tid') {
  $result = db_query(db_rewrite_sql('SELECT t.* FROM {term_node} r INNER JOIN {term_data} t ON r.tid = t.tid INNER JOIN {vocabulary} v ON t.vid = v.vid WHERE r.vid = %d ORDER BY v.weight, t.weight, t.name', 't', 'tid'), $node->vid);
  $terms = array();
  while ($term = db_fetch_object($result)) {
    $terms[$term->$key] = $term;
  }
  return $terms;
}

/**
 * Translate an array of taxonomy terms.
 *
 * Translates all terms with language, just passing over terms without it.
 * Filter out terms with a different language
 *
 * @param $taxonomy
 *   Array of term objects or tids or multiple arrays or terms indexed by vid
 * @param $langcode
 *   Language code of target language
 * @param $fullterms
 *   Whether to return full $term objects, returns tids otherwise
 * @return
 *   Array with translated terms: tid -> $term
 *   Array with vid and term array
 */
function i18n_taxonomy_translate_terms($taxonomy, $langcode, $fullterms = TRUE) {
  $translation = array();
  if (is_array($taxonomy) && $taxonomy) {
    foreach ($taxonomy as $index => $tdata) {
      if (is_array($tdata)) {
        // Case 1: Index is vid, $tdata is an array of terms
        $mode = i18n_taxonomy_vocabulary_mode($index);
        // We translate just some vocabularies: translatable, fixed language
        // Fixed language ones may have terms translated, though the UI doesn't support it
        if ($mode == I18N_MODE_LANGUAGE || $mode == I18N_MODE_TRANSLATE) {
          $translation[$index] = i18n_taxonomy_translate_terms($tdata, $langcode, $filter, $fullterms);
        }
        elseif ($fullterms) {
          $translation[$index] = array_map('_i18n_taxonomy_filter_terms', $tdata);
        }
        else {
          $translation[$index] = array_map('_i18n_taxonomy_filter_tids', $tdata);
        }
        continue;
      }
      elseif (is_object($tdata)) {
        // Case 2: This is a term object
        $term = $tdata;
      }
      elseif (is_numeric($tdata) && ($tid = (int)$tdata)) {
        // Case 3: This is a term tid, load the full term
        $term = taxonomy_get_term($tid);
      }
      // Translate the term if we got it
      if (empty($term)) {
        // Couldn't identify term, pass through whatever it is
        $translation[$index] = $tdata;
      }
      elseif ($term->language && $term->language != $langcode) {
        $translated_terms = i18n_taxonomy_term_get_translations(array('tid' => $term->tid));
        if ($translated_terms && !empty($translated_terms[$langcode])) {
          $newterm = $translated_terms[$langcode];
          $translation[$newterm->tid] = $fullterms ? $newterm : $newterm->tid;
        }
      }
      else {
        // Term has no language. Should be ok.
        $translation[$index] = $fullterms ? $term : $term->tid;
      }
    }
  }
  return $translation;
}

/**
 * Localize taxonomy terms for localizable vocabularies.
 *
 * @param $terms
 *   Array of term objects.
 * @param $fields
 *   Object properties to localize.
 * @return
 *   Array of terms with the right ones localized.
 */
function i18n_taxonomy_localize_terms($terms, $fields = array('name')) {
  $terms = is_array($terms) ? $terms : array($terms);
  foreach ($terms as $index => $term) {
    if (i18n_taxonomy_vocabulary_mode($term->vid) === I18N_MODE_LOCALIZE) {
      foreach ($fields as $property) {
        $term->$property = i18n_string(array('taxonomy', 'term', $term->tid, $property), $term->$property);
      }
    }
  }
  return $terms;
}

/**
 * Taxonomy vocabulary settings.
 *
 * @param $vid
 *   Vocabulary object or vocabulary id.
 * @param $mode
 *   Vocabulary mode to compare with.
 *
 */
function i18n_taxonomy_vocabulary_mode($vid, $mode = NULL) {
  $modes = &drupal_static(__FUNCTION__);
  if (is_object($vid)) {
    $vid_mode = isset($vid->i18n_mode) ? $vid->i18n_mode : I18N_MODE_NONE;
    return isset($mode) ? $mode & $vid_mode : $vid_mode;
  }
  else {
    if (!isset($modes[$vid])) {
      $modes[$vid] = taxonomy_vocabulary_load($vid)->i18n_mode;
    }
    return isset($mode) ? $mode & $modes[$vid] : $modes[$vid];
  }
}

/**
 * Returns a list for terms for vocabulary, language.
 *
 * @param $vid
 *   Vocabulary id
 * @param $lang
 *   Language code
 * @param $status
 *   'all' (default), 'translated', 'untranslated'
 */
function i18n_taxonomy_vocabulary_get_terms($vid, $lang, $status = 'all') {
  switch ($status) {
    case 'translated':
      $result = db_query("SELECT * FROM {term_data} WHERE vid = %d AND language = '%s' AND trid > 0", $vid, $lang);
      break;

    case 'untranslated':
      $result = db_query("SELECT * FROM {term_data} WHERE vid = %d AND language = '%s' AND trid = 0", $vid, $lang);
      break;

    default:
      $result = db_query("SELECT * FROM {term_data} WHERE vid = %d AND language = '%s'", $vid, $lang);
      break;
  }
  $list = array();
  while ($term = db_fetch_object($result)) {
    $list[$term->tid] = $term->name;
  }
  return $list;
}

/**
 * Get taxonomy tree for a given language
 *
 * @param $vid
 *   Vocabulary id
 * @param $lang
 *   Language code
 * @param $parent
 *   Parent term id for the tree
 */
function i18n_taxonomy_get_tree($vid, $langcode, $parent = 0, $max_depth = NULL, $load_entities = FALSE) {
  $children = &drupal_static(__FUNCTION__, array());
  $parents = &drupal_static(__FUNCTION__ . ':parents', array());
  $terms = &drupal_static(__FUNCTION__ . ':terms', array());

  // We cache trees, so it's not CPU-intensive to call get_tree() on a term
  // and its children, too.
  if (!isset($children[$vid][$langcode])) {
    $children[$vid][$langcode] = array();
    $parents[$vid][$langcode] = array();
    $terms[$vid][$langcode] = array();

    $query = db_select('taxonomy_term_data', 't');
    $query->join('taxonomy_term_hierarchy', 'h', 'h.tid = t.tid');
    $result = $query
      ->addTag('translatable')
      ->addTag('term_access')
      ->fields('t')
      ->fields('h', array('parent'))
      ->condition('t.vid', $vid)
      ->condition('t.language', $langcode)
      ->orderBy('t.weight')
      ->orderBy('t.name')
      ->execute();

    foreach ($result as $term) {
      $children[$vid][$langcode][$term->parent][] = $term->tid;
      $parents[$vid][$langcode][$term->tid][] = $term->parent;
      $terms[$vid][$langcode][$term->tid] = $term;
    }
  }

  // Load full entities, if necessary. The entity controller statically
  // caches the results.
  if ($load_entities) {
    $term_entities = taxonomy_term_load_multiple(array_keys($terms[$vid][$langcode]));
  }

  $max_depth = (!isset($max_depth)) ? count($children[$vid][$langcode]) : $max_depth;
  $tree = array();

  // Keeps track of the parents we have to process, the last entry is used
  // for the next processing step.
  $process_parents = array();
  $process_parents[] = $parent;

  // Loops over the parent terms and adds its children to the tree array.
  // Uses a loop instead of a recursion, because it's more efficient.
  while (count($process_parents)) {
    $parent = array_pop($process_parents);
    // The number of parents determines the current depth.
    $depth = count($process_parents);
    if ($max_depth > $depth && !empty($children[$vid][$langcode][$parent])) {
      $has_children = FALSE;
      $child = current($children[$vid][$langcode][$parent]);
      do {
        if (empty($child)) {
          break;
        }
        $term = $load_entities ? $term_entities[$child] : $terms[$vid][$langcode][$child];
        if (count($parents[$vid][$langcode][$term->tid]) > 1) {
          // We have a term with multi parents here. Clone the term,
          // so that the depth attribute remains correct.
          $term = clone $term;
        }
        $term->depth = $depth;
        unset($term->parent);
        $term->parents = $parents[$vid][$langcode][$term->tid];
        $tree[] = $term;
        if (!empty($children[$vid][$term->tid])) {
          $has_children = TRUE;

          // We have to continue with this parent later.
          $process_parents[] = $parent;
          // Use the current term as parent for the next iteration.
          $process_parents[] = $term->tid;

          // Reset pointers for child lists because we step in there more often
          // with multi parents.
          reset($children[$vid][$langcode][$term->tid]);
          // Move pointer so that we get the correct term the next time.
          next($children[$vid][$langcode][$parent]);
          break;
        }
      } while ($child = next($children[$vid][$langcode][$parent]));

      if (!$has_children) {
        // We processed all terms in this hierarchy-level, reset pointer
        // so that this function works the next time it gets called.
        reset($children[$vid][$langcode][$parent]);
      }
    }
  }

  return $tree;
}

/**
 * Translate forums list.
 */
function i18n_taxonomy_preprocess_forum_list(&$variables) {
  $vid = variable_get('forum_nav_vocabulary', '');
  if (i18n_taxonomy_vocabulary_mode($vid)) {
    foreach ($variables['forums'] as $id => $forum) {
      $variables['forums'][$id]->description = i18n_string('taxonomy:term:'. $forum->tid .':description', $forum->description);
      $variables['forums'][$id]->name = i18n_string('taxonomy:term:'. $forum->tid .':name', $forum->name);
    }
  }
}

/**
 * Translate forum page.
 */
function i18n_taxonomy_preprocess_forums(&$variables) {
  $vid = variable_get('forum_nav_vocabulary', '');
  if (i18n_taxonomy_vocabulary_mode($vid)) {
    if (isset($variables['links']['forum'])) {
      $variables['links']['forum']['title'] = i18n_string('nodetype:type:forum:post_button', 'Post new Forum topic');
    }
    // This one is from advanced forum, http://drupal.org/project/advanced_forum
    if ($variables['forum_description']) {
      $variables['forum_description'] = i18n_string('taxonomy:term:'. $variables['tid'] .':description', $variables['forum_description']);
    }

    $vocabulary = taxonomy_vocabulary_load($vid);
    // Translate the page title.
    $title = !empty($vocabulary->name) ? i18n_taxonomy_vocabulary_name($vocabulary) : '';
    drupal_set_title($title);

    // Translate the breadcrumb.
    $breadcrumb = array();
    $breadcrumb[] = l(t('Home'), NULL);
    $breadcrumb[] = l($title, 'forum');
    drupal_set_breadcrumb($breadcrumb);
  }
}

/**
 * Recursive array filtering, convert all terms to 'tid'.
 */
function _i18n_taxonomy_filter_tids($tid) {
  if (is_array($tid)) {
    return array_map('_i18n_taxonomy_filter_tids', $tid);
  }
  else {
    return is_object($tid) ? $tid->tid : (int)$tid;
  }
}

/**
 * Recursive array filtering, convert all terms to 'term object'
 */
function _i18n_taxonomy_filter_terms($term) {
  if (is_array($term)) {
    return array_map('_i18n_taxonomy_filter_terms', $term);
  }
  else {
    return is_object($term) ? $term : taxonomy_get_term($term);
  }
}

/**
 * Implements hook_i18n_translation_set_info().
 */
function i18n_taxonomy_i18n_translation_set_info() {
  return array(
    'taxonomy_term' => array(
      'title' => t('Taxonomy terms'),
      'class' => 'i18n_taxonomy_translation_set',
      'entity' => 'taxonomy_term',
    )
  );
}

/**
 * Implements hook i18n_object_info()
 */
function i18n_taxonomy_i18n_object_info() {
  $info['taxonomy_term'] = array(
    'title' => t('Taxonomy term'),
    'entity' => 'taxonomy_term',
    'key' => 'tid',
    'translation set' => array(
      'class' => 'i18n_taxonomy_translation_set',
      'table' => 'taxonomy_term_data',
      'field' => 'i18n_tsid',
    ),
    'string translation' => array(
      'textgroup' => 'taxonomy',
      'type' => 'term',
      'properties' => array(
        'name' => t('Name'),
        'description' => array(
          'title' => t('Description'),
          'format' => 'format',
        ),
      ),
    )
  );
  $info['taxonomy_vocabulary'] = array(
    'title' => t('Vocabulary'),
    'entity' => 'taxonomy_vocabulary',
    'key' => 'vid',
    'string translation' => array(
      'textgroup' => 'taxonomy',
      'type' => 'vocabulary',
      'properties' => array(
        'name' => t('Name'),
        'description' => t('Description'),
      ),
    )
  );
  return $info;
}

/**
 * Load translation set. Menu loading callback.
 */
function i18n_taxonomy_translation_set_load($tsid) {
  return i18n_translation_set_load($tsid, 'taxonomy_term');
}
